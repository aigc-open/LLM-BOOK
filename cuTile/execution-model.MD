# cuTile Python æ‰§è¡Œæ¨¡å‹è¯¦è§£

## ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æŠ½è±¡æœºå™¨æ¨¡å‹](#æŠ½è±¡æœºå™¨æ¨¡å‹)
3. [æ‰§è¡Œç©ºé—´](#æ‰§è¡Œç©ºé—´)
4. [Tile å‡½æ•°](#tile-å‡½æ•°)
5. [Tile å†…æ ¸](#tile-å†…æ ¸)
6. [Python å­é›†](#python-å­é›†)
7. [Tile å¹¶è¡Œæ€§](#tile-å¹¶è¡Œæ€§)
8. [å¸¸é‡æ€§](#å¸¸é‡æ€§)
9. [å®æˆ˜ç¤ºä¾‹](#å®æˆ˜ç¤ºä¾‹)

---

## æ¦‚è¿°

cuTile Python çš„æ‰§è¡Œæ¨¡å‹å®šä¹‰äº†ä»£ç å¦‚ä½•åœ¨ GPU ä¸Šæ‰§è¡Œã€‚ç†è§£æ‰§è¡Œæ¨¡å‹å¯¹äºç¼–å†™é«˜æ•ˆçš„ GPU ç¨‹åºè‡³å…³é‡è¦ã€‚

**æ ¸å¿ƒæ¦‚å¿µï¼š**
- **Blockï¼ˆå—ï¼‰**: æ‰§è¡Œå•å…ƒï¼Œå¤šä¸ªçº¿ç¨‹çš„é›†åˆ
- **Tileï¼ˆæ•°æ®å—ï¼‰**: æ•°æ®å•å…ƒï¼Œå†…å­˜ä¸­çš„æ•°æ®ç‰‡æ®µ
- **Gridï¼ˆç½‘æ ¼ï¼‰**: Block çš„ç»„ç»‡æ–¹å¼ï¼ˆ1D/2D/3Dï¼‰
- **Threadï¼ˆçº¿ç¨‹ï¼‰**: æœ€å°æ‰§è¡Œå•ä½ï¼ˆåœ¨ Tile ç¼–ç¨‹ä¸­æ˜¯éšå¼çš„ï¼‰

**é‡è¦åŒºåˆ†ï¼š**
> âš ï¸ **Block â‰  Tile**
> - **Block** æ˜¯**æ‰§è¡Œå•å…ƒ**ï¼Œè´Ÿè´£è¿è¡Œä»£ç 
> - **Tile** æ˜¯**æ•°æ®å•å…ƒ**ï¼Œæ˜¯è¦å¤„ç†çš„æ•°æ®
> - ä¸€ä¸ª Block å¯ä»¥å¤„ç†å¤šä¸ªä¸åŒå½¢çŠ¶çš„ Tile

---

## æŠ½è±¡æœºå™¨æ¨¡å‹

### Block ä¸ Grid

cuTile å†…æ ¸ç”±ä¸€ä¸ªç½‘æ ¼ï¼ˆGridï¼‰ä¸­çš„å¤šä¸ªé€»è¾‘çº¿ç¨‹å—ï¼ˆBlockï¼‰æ‰§è¡Œã€‚

```
Grid ç»„ç»‡æ–¹å¼ï¼š

1D Grid:     [Blockâ‚€][Blockâ‚][Blockâ‚‚]...[Blockâ‚™]

2D Grid:     Blockâ‚€â‚€  Blockâ‚€â‚  Blockâ‚€â‚‚
             Blockâ‚â‚€  Blockâ‚â‚  Blockâ‚â‚‚
             Blockâ‚‚â‚€  Blockâ‚‚â‚  Blockâ‚‚â‚‚

3D Grid:     å¤šå±‚ 2D ç½‘æ ¼å †å 
```

### Block çš„æ‰§è¡Œæœºåˆ¶

**1. å¹¶è¡Œæ‰§è¡Œ**
```python
# æ¯ä¸ª Block ç‹¬ç«‹æ‰§è¡Œå†…æ ¸ä»£ç 
grid = (8, 1, 1)  # 8 ä¸ª Block å¹¶è¡Œæ‰§è¡Œ
ct.launch(stream, grid, kernel, args)
```

**2. æ ‡é‡æ“ä½œ vs æ•°ç»„æ“ä½œ**

```python
@ct.kernel
def example_kernel(a, b, c):
    # æ ‡é‡æ“ä½œï¼šç”± Block ä¸­çš„å•ä¸ªçº¿ç¨‹ä¸²è¡Œæ‰§è¡Œ
    pid = ct.bid(0)  # æ ‡é‡ï¼šBlock ID
    offset = pid * 16  # æ ‡é‡ï¼šè®¡ç®—åç§»é‡
    
    # æ•°ç»„æ“ä½œï¼šç”± Block ä¸­çš„æ‰€æœ‰çº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ
    a_tile = ct.load(a, index=(pid,), shape=(16,))  # Tileï¼š16 ä¸ªå…ƒç´ 
    b_tile = ct.load(b, index=(pid,), shape=(16,))  # Tileï¼š16 ä¸ªå…ƒç´ 
    result = a_tile + b_tile  # Tile æ“ä½œï¼šæ‰€æœ‰å…ƒç´ å¹¶è¡Œç›¸åŠ 
```

**æ“ä½œç±»å‹å¯¹æ¯”ï¼š**

| æ“ä½œç±»å‹ | æ‰§è¡Œæ–¹å¼ | ç¤ºä¾‹ |
|---------|---------|------|
| **æ ‡é‡æ“ä½œ** | å•çº¿ç¨‹ä¸²è¡Œ | `pid = ct.bid(0)`, `x = 5 + 3` |
| **æ•°ç»„æ“ä½œ** | å¤šçº¿ç¨‹å¹¶è¡Œ | `result = a_tile + b_tile` |

### æ˜¾å¼å¹¶è¡Œ vs éšå¼å¹¶è¡Œ

**cuTile çš„ç‰¹ç‚¹ï¼š**
- âœ… **æ˜¾å¼æè¿° Block çº§å¹¶è¡Œ**ï¼šç¨‹åºå‘˜æŒ‡å®šæœ‰å¤šå°‘ä¸ª Block
- âŒ **éšå¼å¤„ç† Thread çº§å¹¶è¡Œ**ï¼šçº¿ç¨‹ç”±ç³»ç»Ÿè‡ªåŠ¨ç®¡ç†
- âŒ **ä¸èƒ½ç›´æ¥æ“ä½œçº¿ç¨‹**ï¼šæ— æ³•è¯†åˆ«æˆ–æ§åˆ¶å•ä¸ªçº¿ç¨‹

```python
# âœ… æ˜¾å¼æŒ‡å®š Block æ•°é‡
grid = (256, 1, 1)  # 256 ä¸ª Block

# âŒ æ— æ³•æŒ‡å®šçº¿ç¨‹æ•°é‡ï¼ˆç”±ç³»ç»Ÿå†³å®šï¼‰
# æ—  threadIdx, blockDim ç­‰æ¦‚å¿µ
```

### Block é—´åŒæ­¥ä¸é€šä¿¡

**è§„åˆ™ï¼š**
- âŒ **Block å†…ä¸å…è®¸æ˜¾å¼åŒæ­¥/é€šä¿¡**ï¼ˆç”±ç³»ç»Ÿéšå¼å¤„ç†ï¼‰
- âœ… **Block é—´å…è®¸åŒæ­¥/é€šä¿¡**ï¼ˆé€šè¿‡å…¨å±€å†…å­˜ï¼‰

```python
# âŒ Block å†…æ— éœ€æ˜¾å¼åŒæ­¥ï¼ˆè‡ªåŠ¨å¤„ç†ï¼‰
# ä¸éœ€è¦ __syncthreads() è¿™æ ·çš„æ“ä½œ

# âœ… Block é—´å¯ä»¥é€šè¿‡å…¨å±€å†…å­˜é€šä¿¡
@ct.kernel
def cross_block_comm(data, flags):
    pid = ct.bid(0)
    # Block é—´é€šè¿‡å…¨å±€å†…å­˜äº¤æ¢æ•°æ®
    # ä½†éœ€è¦ä½¿ç”¨åŸå­æ“ä½œæˆ– barrier ç¡®ä¿ä¸€è‡´æ€§
```

---

## æ‰§è¡Œç©ºé—´

æ‰§è¡Œç©ºé—´ï¼ˆExecution Spaceï¼‰å®šä¹‰äº†ä»£ç å¯ä»¥åœ¨å“ªäº›ç¯å¢ƒä¸­è¿è¡Œã€‚

### ä¸‰ç§æ‰§è¡Œç©ºé—´

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Host Code (CPU)                â”‚  â† Python æ ‡å‡†ä»£ç 
â”‚  âœ“ å¯ä»¥è°ƒç”¨ @ct.kernel                  â”‚
â”‚  âœ“ å¯ä»¥è°ƒç”¨ host=True çš„å‡½æ•°            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â”‚ ct.launch()
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Tile Code (GPU)                 â”‚  â† cuTile å†…æ ¸ä»£ç 
â”‚  âœ“ ä½¿ç”¨ Tile æŠ½è±¡                       â”‚
â”‚  âœ“ ä¸èƒ½ç›´æ¥è®¿é—®çº¿ç¨‹                     â”‚
â”‚  âœ“ å¯ä»¥è°ƒç”¨ @ct.function                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        SIMT Code (GPU)                  â”‚  â† ä¼ ç»Ÿ CUDA ä»£ç 
â”‚  âœ“ ç›´æ¥æ“ä½œçº¿ç¨‹ï¼ˆthreadIdx ç­‰ï¼‰         â”‚
â”‚  âœ“ ä¸ Tile Code æ˜¯ä¸åŒçš„æ‰§è¡Œç©ºé—´         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯ç”¨æ€§ï¼ˆUsabilityï¼‰

**å®šä¹‰ï¼š**
- **å‡½æ•°å¯ç”¨**ï¼šå¯ä»¥è¢«è°ƒç”¨
- **ç±»å‹/å¯¹è±¡å¯ç”¨**ï¼šå±æ€§å¯ä»¥è®¿é—®ï¼Œæ–¹æ³•å¯ä»¥è°ƒç”¨

**æ‰§è¡Œç©ºé—´é™åˆ¶ï¼š**
æŸäº›å‡½æ•°ã€ç±»å‹å’Œå¯¹è±¡åªèƒ½åœ¨ç‰¹å®šçš„æ‰§è¡Œç©ºé—´ä¸­ä½¿ç”¨ã€‚

### Host Codeï¼ˆä¸»æœºä»£ç ï¼‰

```python
import cupy as cp
import cuda.tile as ct

# Host Codeï¼šåœ¨ CPU ä¸Šæ‰§è¡Œ
def main():
    a = cp.random.rand(1024)  # âœ… CuPy åœ¨ Host å¯ç”¨
    b = cp.zeros(1024)
    
    grid = (64, 1, 1)
    ct.launch(stream, grid, my_kernel, (a, b))  # âœ… å¯åŠ¨å†…æ ¸
```

### Tile Codeï¼ˆTile ä»£ç ï¼‰

```python
@ct.kernel
def my_kernel(a, b):
    # Tile Codeï¼šåœ¨ GPU ä¸Šæ‰§è¡Œ
    pid = ct.bid(0)  # âœ… ct.bid() åœ¨ Tile Code å¯ç”¨
    
    tile_a = ct.load(a, index=(pid,), shape=(16,))  # âœ… ct.load() å¯ç”¨
    result = tile_a * 2.0  # âœ… Tile æ“ä½œå¯ç”¨
    
    ct.store(b, index=(pid,), tile=result)  # âœ… ct.store() å¯ç”¨
    
    # âŒ print() ä¸åœ¨ Tile Code å¯ç”¨ï¼ˆæ—  Python è¿è¡Œæ—¶ï¼‰
    # âŒ cp.random.rand() ä¸åœ¨ Tile Code å¯ç”¨
```

### SIMT Codeï¼ˆSIMT ä»£ç ï¼‰

ä¼ ç»Ÿ CUDA ç¼–ç¨‹æ¨¡å‹ï¼Œä¸ Tile Code æ˜¯ä¸åŒçš„æ‰§è¡Œç©ºé—´ï¼š

```cuda
// SIMT Codeï¼šä¼ ç»Ÿ CUDA å†…æ ¸
__global__ void simt_kernel(float* a, float* b, int n) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;  // ç›´æ¥è®¿é—®çº¿ç¨‹ç´¢å¼•
    if (idx < n) {
        b[idx] = a[idx] * 2.0f;
    }
}
```

---

## Tile å‡½æ•°

### åŸºæœ¬æ¦‚å¿µ

Tile å‡½æ•°æ˜¯å¯ä»¥åœ¨ Tile Code ä¸­è°ƒç”¨çš„å‡½æ•°ã€‚

### è£…é¥°å™¨ï¼š`@ct.function`

```python
class cuda.tile.function(func=None, /, *, host=False, tile=True)
```

**å‚æ•°ï¼š**
- `host` (bool): æ˜¯å¦å¯ä»¥ä» Host Code è°ƒç”¨ï¼Œé»˜è®¤ `False`
- `tile` (bool): æ˜¯å¦å¯ä»¥ä» Tile Code è°ƒç”¨ï¼Œé»˜è®¤ `True`

### ä½¿ç”¨ç¤ºä¾‹

#### ç¤ºä¾‹ 1ï¼šä»…åœ¨ Tile Code å¯ç”¨

```python
import cuda.tile as ct

@ct.function  # ç­‰ä»·äº @ct.function(host=False, tile=True)
def compute_square(x):
    """ä»…èƒ½åœ¨ Tile Code ä¸­è°ƒç”¨"""
    return x * x

@ct.kernel
def kernel_example(a, b):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    # âœ… åœ¨ Tile Code ä¸­è°ƒç”¨
    result = compute_square(tile_a)
    
    ct.store(b, index=(pid,), tile=result)

# âŒ ä¸èƒ½åœ¨ Host Code ä¸­è°ƒç”¨
# x = compute_square(5)  # é”™è¯¯ï¼
```

#### ç¤ºä¾‹ 2ï¼šHost å’Œ Tile éƒ½å¯ç”¨

```python
@ct.function(host=True, tile=True)
def add_constant(x, c):
    """åœ¨ Host å’Œ Tile Code éƒ½å¯ä»¥è°ƒç”¨"""
    return x + c

# âœ… Host Code ä¸­è°ƒç”¨
result = add_constant(10, 5)  # è¿”å› 15

@ct.kernel
def kernel_with_shared_func(a, b):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    # âœ… Tile Code ä¸­è°ƒç”¨
    result = add_constant(tile_a, 10.0)
    
    ct.store(b, index=(pid,), tile=result)
```

### è‡ªåŠ¨æ¨æ–­æ‰§è¡Œç©ºé—´

**é‡è¦ç‰¹æ€§ï¼š**
> å½“ä¸€ä¸ª**æœªæ ‡æ³¨çš„å‡½æ•°**è¢« Tile å‡½æ•°è°ƒç”¨æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨è¢«æ·»åŠ åˆ° Tile æ‰§è¡Œç©ºé—´ã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯é€’å½’çš„ï¼Œä¸éœ€è¦æ˜¾å¼æ ‡æ³¨ã€‚

```python
# æœªä½¿ç”¨ @ct.function è£…é¥°å™¨
def helper_add(a, b):
    return a + b

def helper_multiply(a, b):
    # è°ƒç”¨å¦ä¸€ä¸ªæœªæ ‡æ³¨çš„å‡½æ•°
    return helper_add(a, b) * 2

@ct.function
def compute(x):
    # âœ… è°ƒç”¨æœªæ ‡æ³¨çš„å‡½æ•°ä¼šè‡ªåŠ¨å°†å…¶åŠ å…¥ Tile æ‰§è¡Œç©ºé—´
    temp = helper_multiply(x, 5)  # helper_multiply è‡ªåŠ¨å¯ç”¨
    return temp * temp  # helper_add ä¹Ÿè‡ªåŠ¨å¯ç”¨ï¼ˆé€’å½’ï¼‰

@ct.kernel
def my_kernel(a, b):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    result = compute(tile_a)  # âœ… æ‰€æœ‰å‡½æ•°éƒ½å¯ç”¨
    ct.store(b, index=(pid,), tile=result)
```

**æœ€ä½³å®è·µï¼š**
- å¯¹äºæ˜ç¡®åªåœ¨ Tile Code ä½¿ç”¨çš„å‡½æ•°ï¼Œæ˜¾å¼ä½¿ç”¨ `@ct.function` æ ‡æ³¨
- å¯¹äºé€šç”¨å·¥å…·å‡½æ•°ï¼Œå¯ä»¥ä¸æ ‡æ³¨ï¼Œè®©ç³»ç»Ÿè‡ªåŠ¨æ¨æ–­
- å¯¹äºéœ€è¦åœ¨ Host å’Œ Tile å…±äº«çš„å‡½æ•°ï¼Œä½¿ç”¨ `@ct.function(host=True, tile=True)`

### å‚æ•°ç±»å‹

Tile å‡½æ•°çš„å‚æ•°ç±»å‹åœ¨[æ•°æ®æ¨¡å‹](data-model.MD)ä¸­è¯¦ç»†æè¿°ã€‚

**æ”¯æŒçš„å‚æ•°ç±»å‹ï¼š**
- æ ‡é‡ç±»å‹ï¼š`int`, `float`, `bool`
- Tile ç±»å‹ï¼šä» `ct.load()` è¿”å›çš„æ•°ç»„
- å¸¸é‡ç±»å‹ï¼š`ct.Constant[T]`

---

## Tile å†…æ ¸

### åŸºæœ¬æ¦‚å¿µ

Tile å†…æ ¸æ˜¯ç”±ç½‘æ ¼ä¸­æ¯ä¸ª Block æ‰§è¡Œçš„å‡½æ•°ï¼Œæ˜¯ Tile Code çš„å…¥å£ç‚¹ã€‚

### è£…é¥°å™¨ï¼š`@ct.kernel`

```python
class cuda.tile.kernel(function=None, /, **kwargs)
```

**å‚æ•°ï¼š**
- `num_ctas`: CGA ä¸­çš„ CTA æ•°é‡ï¼ˆå¿…é¡»æ˜¯ 1-16 ä¹‹é—´çš„ 2 çš„å¹‚ï¼‰ï¼Œé»˜è®¤ï¼š`None`ï¼ˆè‡ªåŠ¨ï¼‰
- `occupancy`: æ¯ä¸ª SM çš„æ´»è·ƒ CTA é¢„æœŸæ•°é‡ [1, 32]ï¼Œé»˜è®¤ï¼š`None`ï¼ˆè‡ªåŠ¨ï¼‰
- `opt_level`: ä¼˜åŒ–çº§åˆ« [0, 3]ï¼Œé»˜è®¤ï¼š`3`

**ç‰¹æ€§ï¼š**
- âœ… å†…æ ¸æ˜¯ Tile Code çš„å…¥å£ç‚¹
- âŒ å†…æ ¸**ä¸èƒ½**ä» Host Code ç›´æ¥è°ƒç”¨
- âœ… å¿…é¡»ä½¿ç”¨ `ct.launch()` å¯åŠ¨å†…æ ¸

### åŸºæœ¬ç¤ºä¾‹

```python
import cuda.tile as ct
import cupy as cp

@ct.kernel
def simple_kernel(a, b, c):
    """
    ç®€å•çš„å‘é‡åŠ æ³•å†…æ ¸
    
    æ¯ä¸ª Block å¤„ç†ä¸€ä¸ª Tile
    """
    # è·å– Block ID
    pid = ct.bid(0)
    
    # åŠ è½½æ•°æ®
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    tile_b = ct.load(b, index=(pid,), shape=(16,))
    
    # è®¡ç®—
    tile_c = tile_a + tile_b
    
    # å­˜å‚¨ç»“æœ
    ct.store(c, index=(pid,), tile=tile_c)

# Host Codeï¼šå¯åŠ¨å†…æ ¸
def main():
    n = 1024
    a = cp.random.rand(n).astype(cp.float32)
    b = cp.random.rand(n).astype(cp.float32)
    c = cp.zeros(n, dtype=cp.float32)
    
    tile_size = 16
    num_blocks = n // tile_size  # 64 ä¸ª Block
    grid = (num_blocks, 1, 1)
    
    stream = cp.cuda.get_current_stream()
    
    # âœ… ä½¿ç”¨ ct.launch() å¯åŠ¨å†…æ ¸
    ct.launch(stream, grid, simple_kernel, (a, b, c))
    
    # âŒ ä¸èƒ½ç›´æ¥è°ƒç”¨
    # simple_kernel(a, b, c)  # é”™è¯¯ï¼
```

### å¤šç»´ Grid ç¤ºä¾‹

```python
@ct.kernel
def matrix_kernel(matrix, output):
    """
    2D Grid å¤„ç†çŸ©é˜µ
    """
    # è·å– 2D Block ç´¢å¼•
    row = ct.bid(0)  # Y ç»´åº¦
    col = ct.bid(1)  # X ç»´åº¦
    
    # åŠ è½½ 2D Tile
    tile = ct.load(matrix, index=(row, col), shape=(16, 16))
    
    # å¤„ç†
    result = tile * 2.0
    
    # å­˜å‚¨
    ct.store(output, index=(row, col), tile=result)

# å¯åŠ¨ 2D Grid
def main():
    matrix = cp.random.rand(256, 256).astype(cp.float32)
    output = cp.zeros_like(matrix)
    
    tile_h, tile_w = 16, 16
    grid_y = 256 // tile_h  # 16
    grid_x = 256 // tile_w  # 16
    grid = (grid_y, grid_x, 1)  # 2D Grid: 16Ã—16
    
    stream = cp.cuda.get_current_stream()
    ct.launch(stream, grid, matrix_kernel, (matrix, output))
```

### é«˜çº§å‚æ•°é…ç½®

```python
from cuda.tile import ByTarget

@ct.kernel(
    num_ctas=4,      # æ¯ä¸ª CGA 4 ä¸ª CTA
    occupancy=16,    # æ¯ä¸ª SM 16 ä¸ªæ´»è·ƒ CTA
    opt_level=3      # æœ€é«˜ä¼˜åŒ–çº§åˆ«
)
def optimized_kernel(a, b):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(32,))
    result = tile_a * 2.0
    ct.store(b, index=(pid,), tile=result)

# é’ˆå¯¹ä¸åŒç›®æ ‡çš„é…ç½®
@ct.kernel(
    num_ctas=ByTarget(sm_90=8, sm_80=4),  # ä¸åŒæ¶æ„ä¸åŒé…ç½®
    occupancy=ByTarget(sm_90=32, sm_80=16)
)
def target_specific_kernel(a, b):
    # å†…æ ¸ä»£ç 
    pass
```

### å¯åŠ¨å†…æ ¸ï¼š`ct.launch()`

```python
cuda.tile.launch(stream, grid, kernel, kernel_args, /)
```

**å‚æ•°ï¼š**
- `stream`: CUDA æµå¯¹è±¡
- `grid`: æœ€å¤š 3 ä¸ªç»´åº¦çš„å…ƒç»„ `(dim_x, dim_y, dim_z)`
- `kernel`: è¦æ‰§è¡Œçš„å†…æ ¸å‡½æ•°
- `kernel_args`: ä¼ é€’ç»™å†…æ ¸çš„ä½ç½®å‚æ•°å…ƒç»„

**ç¤ºä¾‹ï¼š**

```python
# 1D Grid
grid = (256, 1, 1)
ct.launch(stream, grid, kernel_1d, (a, b, c))

# 2D Grid
grid = (16, 16, 1)
ct.launch(stream, grid, kernel_2d, (matrix, output))

# 3D Grid
grid = (8, 8, 8)
ct.launch(stream, grid, kernel_3d, (volume, result))
```

---

## Python å­é›†

### æ ¸å¿ƒé™åˆ¶

**é‡è¦ï¼š** Tile Code ä¸­æ²¡æœ‰ Python è¿è¡Œæ—¶ï¼

> âš ï¸ **åªæœ‰æœ¬æ–‡æ¡£ä¸­æ˜ç¡®åˆ—ä¸¾çš„ Python ç‰¹æ€§æ‰è¢«æ”¯æŒã€‚**

**ä¸æ”¯æŒçš„ç‰¹æ€§ï¼ˆéƒ¨åˆ†ï¼‰ï¼š**
- âŒ Lambda è¡¨è¾¾å¼
- âŒ å¼‚å¸¸å¤„ç†ï¼ˆtry/exceptï¼‰
- âŒ åç¨‹ï¼ˆasync/awaitï¼‰
- âŒ åŠ¨æ€ç±»å‹ç‰¹æ€§
- âŒ åå°„/å…ƒç¼–ç¨‹
- âŒ æ–‡ä»¶ I/O
- âŒ å¤§éƒ¨åˆ†æ ‡å‡†åº“

### å¯¹è±¡æ¨¡å‹ä¸ç”Ÿå‘½å‘¨æœŸ

#### ä¸å¯å˜æ€§è§„åˆ™

**æ ¸å¿ƒè§„åˆ™ï¼š**
> åœ¨ Tile Code ä¸­åˆ›å»ºçš„æ‰€æœ‰å¯¹è±¡éƒ½æ˜¯**ä¸å¯å˜çš„**ã€‚

```python
@ct.kernel
def immutable_demo(a, b):
    pid = ct.bid(0)
    
    # âœ… åˆ›å»ºæ–°å¯¹è±¡
    x = 10
    
    # âŒ ä¸èƒ½ä¿®æ”¹ xï¼ˆæ¦‚å¿µä¸Šåˆ›å»ºæ–°å¯¹è±¡ï¼‰
    x = x + 5  # è¿™ä¼šåˆ›å»ºæ–°çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¿®æ”¹åŸå¯¹è±¡
    
    # âœ… Tile æ“ä½œåˆ›å»ºæ–° Tile
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    tile_b = tile_a * 2  # åˆ›å»ºæ–° Tileï¼Œä¸ä¿®æ”¹ tile_a
    
    # âŒ ä¸èƒ½åŠ¨æ€æ·»åŠ å±æ€§
    # tile_a.new_attr = 5  # é”™è¯¯ï¼
```

#### å¯å˜å¯¹è±¡ï¼šæ•°ç»„

**å”¯ä¸€ä¾‹å¤–ï¼š** ä½œä¸ºå†…æ ¸å‚æ•°ä¼ å…¥çš„**æ•°ç»„**æ˜¯å¯å˜çš„ã€‚

```python
@ct.kernel
def array_mutation(a, b):
    pid = ct.bid(0)
    
    # âœ… å¯ä»¥ä¿®æ”¹æ•°ç»„å†…å®¹ï¼ˆé€šè¿‡ ct.store()ï¼‰
    tile = ct.load(a, index=(pid,), shape=(16,))
    result = tile * 2
    ct.store(a, index=(pid,), tile=result)  # âœ… ä¿®æ”¹æ•°ç»„ a
    ct.store(b, index=(pid,), tile=result)  # âœ… ä¿®æ”¹æ•°ç»„ b
```

**è°ƒç”¨è€…è´£ä»»ï¼š**

è°ƒç”¨è€…å¿…é¡»ç¡®ä¿ï¼š
1. âŒ **ä¼ é€’ç»™å†…æ ¸çš„æ•°ç»„ä¸èƒ½äº’ç›¸åˆ«åï¼ˆaliasï¼‰**
2. âœ… **æ‰€æœ‰æ•°ç»„åœ¨å†…æ ¸æ‰§è¡Œå®Œæˆå‰ä¿æŒæœ‰æ•ˆ**

```python
# âŒ é”™è¯¯ï¼šæ•°ç»„åˆ«å
a = cp.arange(100)
ct.launch(stream, grid, kernel, (a, a))  # å±é™©ï¼a ä¼ é€’ä¸¤æ¬¡

# âœ… æ­£ç¡®ï¼šä¸åŒæ•°ç»„
a = cp.arange(100)
b = cp.zeros(100)
ct.launch(stream, grid, kernel, (a, b))

# âœ… æ­£ç¡®ï¼šç¡®ä¿ç”Ÿå‘½å‘¨æœŸ
def safe_launch():
    a = cp.arange(100)
    b = cp.zeros(100)
    stream = cp.cuda.get_current_stream()
    ct.launch(stream, grid, kernel, (a, b))
    stream.synchronize()  # ç­‰å¾…å†…æ ¸å®Œæˆ
    # a, b åœ¨å†…æ ¸å®Œæˆåæ‰ä¼šè¢«é‡Šæ”¾
```

### æ§åˆ¶æµ

#### æ”¯æŒçš„è¯­å¥

cuTile æ”¯æŒ Python çš„æ§åˆ¶æµè¯­å¥ï¼š

**1. if è¯­å¥**

```python
@ct.kernel
def conditional_kernel(a, b, threshold: ct.Constant[float]):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    # âœ… if-else
    if pid < 10:
        result = tile_a * 2.0
    else:
        result = tile_a * 0.5
    
    ct.store(b, index=(pid,), tile=result)
```

**2. for å¾ªç¯**

```python
@ct.kernel
def loop_kernel(a, b, iterations: ct.Constant[int]):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    result = tile_a
    # âœ… for range å¾ªç¯
    for i in range(iterations):
        result = result * 1.1
    
    ct.store(b, index=(pid,), tile=result)
```

**3. while å¾ªç¯**

```python
@ct.kernel
def while_kernel(a, b, max_iter: ct.Constant[int]):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    result = tile_a
    count = 0
    
    # âœ… while å¾ªç¯
    while count < max_iter:
        result = result * 0.99
        count = count + 1
    
    ct.store(b, index=(pid,), tile=result)
```

**4. åµŒå¥—æ§åˆ¶æµ**

```python
@ct.kernel
def nested_control(a, b, c):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    # âœ… ä»»æ„åµŒå¥—
    if pid % 2 == 0:
        for i in range(5):
            if i > 2:
                tile_a = tile_a * 1.5
            else:
                tile_a = tile_a * 0.5
    
    ct.store(b, index=(pid,), tile=tile_a)
```

#### å½“å‰é™åˆ¶

**âš ï¸ range() çš„ step å¿…é¡»ä¸¥æ ¼ä¸ºæ­£**

```python
# âœ… æ­£å‘å¾ªç¯ï¼ˆstep > 0ï¼‰
for i in range(10):  # step é»˜è®¤ä¸º 1
    pass

for i in range(0, 20, 2):  # step = 2
    pass

# âŒ ä¸æ”¯æŒè´Ÿæ­¥é•¿
for i in range(10, 0, -1):  # é”™è¯¯ï¼ä¸æ”¯æŒ
    pass

# âš ï¸ é€šè¿‡å˜é‡ä¼ é€’è´Ÿæ­¥é•¿ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸º
step = -1
for i in range(10, 0, step):  # æœªå®šä¹‰è¡Œä¸ºï¼
    pass
```

**è§£å†³æ–¹æ¡ˆï¼š** ä½¿ç”¨æ­£å‘å¾ªç¯å¹¶è°ƒæ•´ç´¢å¼•

```python
# éœ€è¦åå‘éå†æ—¶ï¼Œæ‰‹åŠ¨è®¡ç®—ç´¢å¼•
n = 10
for i in range(n):
    actual_index = n - 1 - i  # ä» 9 åˆ° 0
    # ä½¿ç”¨ actual_index
```

---

## Tile å¹¶è¡Œæ€§

### å¹¶è¡Œæ‰§è¡Œæ¨¡å‹

å½“ Block æ‰§è¡Œä¸€ä¸ªæ¥å— Tile ä½œä¸ºå‚æ•°çš„å‡½æ•°æ—¶ï¼Œå®ƒå¯ä»¥è·¨ Block çš„æ‰§è¡Œèµ„æºå¹¶è¡ŒåŒ–å‡½æ•°æ±‚å€¼ã€‚

```python
@ct.function
def process_tile(tile):
    """
    è¿™ä¸ªå‡½æ•°æ¥å— Tile ä½œä¸ºå‚æ•°
    Block ä¼šè‡ªåŠ¨å¹¶è¡ŒåŒ– Tile ä¸Šçš„æ“ä½œ
    """
    return tile * 2.0 + 1.0

@ct.kernel
def parallel_kernel(a, b):
    pid = ct.bid(0)
    tile_a = ct.load(a, index=(pid,), shape=(128,))
    
    # Tile æ“ä½œä¼šè¢«è‡ªåŠ¨å¹¶è¡ŒåŒ–
    # 128 ä¸ªå…ƒç´ çš„è®¡ç®—ä¼šåˆ†é…ç»™å¤šä¸ªçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œ
    result = process_tile(tile_a)
    
    ct.store(b, index=(pid,), tile=result)
```

**å¹¶è¡Œæ‰§è¡Œç¤ºæ„ï¼š**

```
Tile: [eâ‚€, eâ‚, eâ‚‚, eâ‚ƒ, eâ‚„, eâ‚…, eâ‚†, eâ‚‡, ...]
      â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
      â†“   â†“   â†“   â†“   â†“   â†“   â†“   â†“
    Threadâ‚€ Threadâ‚ Threadâ‚‚ Threadâ‚ƒ ...
      â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
      â†“   â†“   â†“   â†“   â†“   â†“   â†“   â†“
    [râ‚€, râ‚, râ‚‚, râ‚ƒ, râ‚„, râ‚…, râ‚†, râ‚‡, ...]

æ‰€æœ‰çº¿ç¨‹å¹¶è¡Œæ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œä½†å¤„ç†ä¸åŒçš„å…ƒç´ 
```

### åŒæ­¥ä¿è¯

**é‡è¦ä¿è¯ï¼š**
> é™¤éå¦æœ‰è¯´æ˜ï¼Œå‡½æ•°æ‰§è¡Œå°†åœ¨å‡½æ•°è¿”å›å‰å®Œæˆã€‚

```python
@ct.kernel
def sync_guaranteed(a, b, c):
    pid = ct.bid(0)
    
    # åŠ è½½å®Œæˆåæ‰ç»§ç»­
    tile_a = ct.load(a, index=(pid,), shape=(16,))
    
    # è®¡ç®—å®Œæˆåæ‰ç»§ç»­
    result = tile_a * 2.0
    
    # å­˜å‚¨å®Œæˆåæ‰ç»§ç»­
    ct.store(b, index=(pid,), tile=result)
    
    # æ‰€æœ‰ä¸Šè¿°æ“ä½œéƒ½ä¿è¯å®Œæˆåï¼Œæ‰ä¼šåˆ°è¾¾è¿™é‡Œ
    # ä¸éœ€è¦æ˜¾å¼çš„ __syncthreads()
```

**å¯¹æ¯”ä¼ ç»Ÿ CUDAï¼š**

```cuda
// ä¼ ç»Ÿ CUDAï¼šéœ€è¦æ˜¾å¼åŒæ­¥
__global__ void cuda_kernel(float* a, float* b) {
    __shared__ float temp[16];
    int tid = threadIdx.x;
    
    temp[tid] = a[tid];
    __syncthreads();  // â— æ˜¾å¼åŒæ­¥
    
    b[tid] = temp[tid] * 2.0f;
}
```

```python
# cuTileï¼šè‡ªåŠ¨åŒæ­¥
@ct.kernel
def cutile_kernel(a, b):
    pid = ct.bid(0)
    tile = ct.load(a, index=(pid,), shape=(16,))
    # âœ… è‡ªåŠ¨åŒæ­¥ï¼Œä¸éœ€è¦æ˜¾å¼è°ƒç”¨
    result = tile * 2.0
    ct.store(b, index=(pid,), tile=result)
```

---

## å¸¸é‡æ€§

### å¸¸é‡è¡¨è¾¾å¼ä¸å¯¹è±¡

æŸäº›åŠŸèƒ½éœ€è¦åœ¨**ç¼–è¯‘æ—¶é™æ€å·²çŸ¥**çš„å‚æ•°ï¼Œè¿™äº›å‚æ•°å¿…é¡»æ˜¯**å¸¸é‡å¯¹è±¡**ã€‚

### ä»€ä¹ˆæ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Ÿ

**å¸¸é‡è¡¨è¾¾å¼åŒ…æ‹¬ï¼š**

1. **å­—é¢é‡å¯¹è±¡**
   ```python
   x = 42        # æ•´æ•°å­—é¢é‡
   y = 3.14      # æµ®ç‚¹å­—é¢é‡
   z = True      # å¸ƒå°”å­—é¢é‡
   ```

2. **æ•´æ•°ç®—æœ¯è¡¨è¾¾å¼ï¼ˆæ“ä½œæ•°éƒ½æ˜¯å­—é¢é‡ï¼‰**
   ```python
   a = 10 + 20           # å¸¸é‡è¡¨è¾¾å¼ â†’ 30
   b = 5 * 6             # å¸¸é‡è¡¨è¾¾å¼ â†’ 30
   c = (100 - 10) // 3   # å¸¸é‡è¡¨è¾¾å¼ â†’ 30
   ```

3. **ä»å­—é¢é‡æˆ–å¸¸é‡è¡¨è¾¾å¼èµ‹å€¼çš„å±€éƒ¨å¯¹è±¡/å‚æ•°**
   ```python
   tile_size = 16           # å¸¸é‡
   double_size = tile_size * 2  # ä¹Ÿæ˜¯å¸¸é‡ â†’ 32
   ```

4. **ç¼–è¯‘æˆ–å¯åŠ¨æ—¶å®šä¹‰çš„å…¨å±€å¯¹è±¡**
   ```python
   GLOBAL_SIZE = 128  # å…¨å±€å¸¸é‡
   
   @ct.kernel
   def kernel(a):
       # GLOBAL_SIZE æ˜¯å¸¸é‡
       tile = ct.load(a, index=(0,), shape=(GLOBAL_SIZE,))
   ```

### æ¾æ•£ç±»å‹ vs ä¸¥æ ¼ç±»å‹å¸¸é‡

#### æ¾æ•£ç±»å‹å¸¸é‡ï¼ˆé»˜è®¤ï¼‰

```python
# é»˜è®¤æƒ…å†µä¸‹ï¼Œå¸¸é‡æ˜¯æ¾æ•£ç±»å‹çš„
x = 42        # æ— é™ç²¾åº¦æ•´æ•°
y = 3.14      # IEEE 754 åŒç²¾åº¦

# æ¾æ•£ç±»å‹å¸¸é‡ç›´åˆ°éœ€è¦æ—¶æ‰ç¡®å®šå…·ä½“ç±»å‹
result = x + 100  # ä»ç„¶æ˜¯æ¾æ•£ç±»å‹
```

#### ä¸¥æ ¼ç±»å‹å¸¸é‡

```python
import cuda.tile as ct

# åˆ›å»ºä¸¥æ ¼ç±»å‹å¸¸é‡
x = ct.int16(5)      # ä¸¥æ ¼çš„ int16 ç±»å‹
y = ct.float32(3.14) # ä¸¥æ ¼çš„ float32 ç±»å‹

# ä¸¥æ ¼ç±»å‹ + æ¾æ•£ç±»å‹ â†’ ä¸¥æ ¼ç±»å‹
z = ct.int16(5) + 2  # ç»“æœï¼šint16(7)

# ä¸¥æ ¼ç±»å‹ + ä¸¥æ ¼ç±»å‹ â†’ ç±»å‹æå‡
a = ct.int16(5) + ct.int32(7)  # ç»“æœï¼šint32(12)
```

**ç±»å‹æå‡è§„åˆ™ï¼š**

```
int8 â†’ int16 â†’ int32 â†’ int64
float16 â†’ float32 â†’ float64
```

### å¸¸é‡åµŒå…¥ï¼ˆConstant Embeddingï¼‰

#### ä»€ä¹ˆæ˜¯å¸¸é‡åµŒå…¥ï¼Ÿ

å¦‚æœå†…æ ¸å‚æ•°è¢«æ ‡è®°ä¸º**å¸¸é‡åµŒå…¥**ï¼Œåˆ™ï¼š

1. âœ… å‚æ•°çš„æ‰€æœ‰ä½¿ç”¨éƒ½åƒè¢«å­—é¢å€¼æ›¿æ¢ä¸€æ ·
2. âœ… æ¯ä¸ªä¸åŒçš„å‚æ•°å€¼éƒ½ä¼šç”Ÿæˆç‹¬ç«‹çš„å†…æ ¸æœºå™¨ç 
3. âœ… å‚æ•°çš„æœºå™¨è¡¨ç¤ºä¸º 0 å­—èŠ‚ï¼ˆä¸å ç”¨å¯„å­˜å™¨/å†…å­˜ï¼‰

**ä¼˜ç‚¹ï¼š**
- ğŸš€ æ›´æ¿€è¿›çš„ç¼–è¯‘å™¨ä¼˜åŒ–
- ğŸš€ æ›´å°‘çš„å¯„å­˜å™¨ä½¿ç”¨
- ğŸš€ å¯èƒ½å±•å¼€å¾ªç¯å’Œå†…è”æ“ä½œ

**ç¼ºç‚¹ï¼š**
- ğŸ“¦ æ¯ä¸ªä¸åŒå€¼éƒ½ä¼šç¼–è¯‘ä¸€æ¬¡ï¼ˆå¢åŠ ç¼–è¯‘æ—¶é—´ï¼‰
- ğŸ“¦ å¤šä¸ªå€¼ä¼šå¢åŠ ä»£ç ç¼“å­˜å¤§å°

### å¸¸é‡ç±»å‹æç¤º

#### ä½¿ç”¨ `ct.Constant`

```python
import cuda.tile as ct
from typing import Annotated

# æ–¹å¼ 1ï¼šä¸æŒ‡å®šç±»å‹
@ct.kernel
def kernel1(a, b, tile_size: ct.Constant):
    """tile_size å¿…é¡»æ˜¯å¸¸é‡ï¼Œä»»æ„ç±»å‹"""
    tile_a = ct.load(a, index=(0,), shape=(tile_size,))
    ct.store(b, index=(0,), tile=tile_a)

# æ–¹å¼ 2ï¼šæŒ‡å®šç±»å‹
@ct.kernel
def kernel2(a, b, tile_size: ct.Constant[int]):
    """tile_size å¿…é¡»æ˜¯å¸¸é‡ int ç±»å‹"""
    tile_a = ct.load(a, index=(0,), shape=(tile_size,))
    ct.store(b, index=(0,), tile=tile_a)
```

#### å®Œæ•´ç¤ºä¾‹

```python
import cupy as cp
import cuda.tile as ct

@ct.kernel
def constant_embedded_kernel(
    a, b, 
    tile_size: ct.Constant[int],      # å¸¸é‡åµŒå…¥
    scale_factor: ct.Constant[float]  # å¸¸é‡åµŒå…¥
):
    """
    tile_size å’Œ scale_factor ä¼šè¢«å¸¸é‡åµŒå…¥
    """
    pid = ct.bid(0)
    
    # tile_size åœ¨ç¼–è¯‘æ—¶å·²çŸ¥ï¼Œå¯ä»¥è¿›è¡Œæ›´å¤šä¼˜åŒ–
    tile_a = ct.load(a, index=(pid,), shape=(tile_size,))
    
    # scale_factor ä¹Ÿåœ¨ç¼–è¯‘æ—¶å·²çŸ¥
    result = tile_a * scale_factor
    
    ct.store(b, index=(pid,), tile=result)

# ä½¿ç”¨ç¤ºä¾‹
def main():
    n = 1024
    a = cp.random.rand(n).astype(cp.float32)
    b = cp.zeros(n, dtype=cp.float32)
    
    tile_size = 16       # å¸¸é‡å€¼
    scale_factor = 2.5   # å¸¸é‡å€¼
    
    grid = (n // tile_size, 1, 1)
    stream = cp.cuda.get_current_stream()
    
    # ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼štile_size=16, scale_factor=2.5
    ct.launch(stream, grid, constant_embedded_kernel, 
              (a, b, tile_size, scale_factor))
    
    # ç¬¬äºŒæ¬¡è°ƒç”¨ï¼štile_size=32ï¼ˆä¸åŒçš„å€¼ï¼‰
    # ä¼šè§¦å‘é‡æ–°ç¼–è¯‘ï¼
    tile_size2 = 32
    grid2 = (n // tile_size2, 1, 1)
    ct.launch(stream, grid2, constant_embedded_kernel,
              (a, b, tile_size2, scale_factor))
```

### `ct.ConstantAnnotation` ç±»

```python
from typing import Annotated
import cuda.tile as ct

# æ˜¾å¼ä½¿ç”¨ ConstantAnnotation
def custom_function(x: Annotated[int, ct.ConstantAnnotation()]):
    """x å¿…é¡»æ˜¯å¸¸é‡åµŒå…¥çš„ int"""
    return x * 2

# ç­‰ä»·äº
def custom_function2(x: ct.Constant[int]):
    """ä½¿ç”¨ä¾¿æ·çš„ ct.Constant åˆ«å"""
    return x * 2
```

### å¸¸é‡æ€§æœ€ä½³å®è·µ

**âœ… æ¨èä½¿ç”¨å¸¸é‡åµŒå…¥çš„åœºæ™¯ï¼š**

1. **Tile å½¢çŠ¶å‚æ•°**
   ```python
   @ct.kernel
   def kernel(a, b, tile_size: ct.Constant[int]):
       tile = ct.load(a, index=(0,), shape=(tile_size,))  # å½¢çŠ¶éœ€è¦æ˜¯å¸¸é‡
   ```

2. **å¾ªç¯è¾¹ç•Œï¼ˆéœ€è¦å±•å¼€æ—¶ï¼‰**
   ```python
   @ct.kernel
   def unrolled_kernel(a, b, iterations: ct.Constant[int]):
       result = a
       for i in range(iterations):  # ç¼–è¯‘å™¨å¯èƒ½å±•å¼€å¾ªç¯
           result = result * 1.1
       ct.store(b, index=(0,), tile=result)
   ```

3. **é…ç½®å‚æ•°**
   ```python
   @ct.kernel
   def configured_kernel(a, b, 
                         use_fast_math: ct.Constant[bool],
                         precision: ct.Constant[int]):
       tile = ct.load(a, index=(0,), shape=(16,))
       if use_fast_math:
           result = fast_compute(tile)
       else:
           result = accurate_compute(tile)
   ```

**âŒ ä¸æ¨èä½¿ç”¨å¸¸é‡åµŒå…¥çš„åœºæ™¯ï¼š**

1. **é¢‘ç¹å˜åŒ–çš„å‚æ•°**ï¼ˆä¼šå¯¼è‡´å¤§é‡é‡æ–°ç¼–è¯‘ï¼‰
2. **å¤§èŒƒå›´çš„å‚æ•°å€¼**ï¼ˆä¼šç”Ÿæˆå¤§é‡ä¸åŒçš„å†…æ ¸ç‰ˆæœ¬ï¼‰
3. **è¿è¡Œæ—¶æ‰çŸ¥é“çš„æ•°æ®**

---

## å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šå®Œæ•´çš„çŸ©é˜µè½¬ç½®

```python
import cupy as cp
import cuda.tile as ct
import numpy as np

@ct.function
def transpose_tile(tile):
    """
    è½¬ç½®ä¸€ä¸ª 2D Tile
    è¿™ä¸ªå‡½æ•°ä¼šè¢«è‡ªåŠ¨åŠ å…¥ Tile æ‰§è¡Œç©ºé—´
    """
    # å‡è®¾ ct æä¾›äº† transpose æ“ä½œ
    return ct.transpose(tile)

@ct.kernel
def matrix_transpose(input_matrix, output_matrix, 
                     tile_h: ct.Constant[int], 
                     tile_w: ct.Constant[int]):
    """
    çŸ©é˜µè½¬ç½®å†…æ ¸
    
    è¾“å…¥çŸ©é˜µå½¢çŠ¶: (H, W)
    è¾“å‡ºçŸ©é˜µå½¢çŠ¶: (W, H)
    Tile å½¢çŠ¶: (tile_h, tile_w)
    """
    # è·å– 2D Block ç´¢å¼•
    row = ct.bid(0)
    col = ct.bid(1)
    
    # åŠ è½½è¾“å…¥ Tile: (tile_h, tile_w)
    input_tile = ct.load(input_matrix, 
                         index=(row, col), 
                         shape=(tile_h, tile_w))
    
    # è½¬ç½® Tile: (tile_h, tile_w) â†’ (tile_w, tile_h)
    transposed = transpose_tile(input_tile)
    
    # å­˜å‚¨åˆ°è½¬ç½®ä½ç½®
    ct.store(output_matrix, 
             index=(col, row),  # æ³¨æ„ï¼šè¡Œåˆ—äº’æ¢
             tile=transposed)

def test_matrix_transpose():
    """æµ‹è¯•çŸ©é˜µè½¬ç½®"""
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    H, W = 256, 128
    tile_h, tile_w = 16, 16
    
    input_matrix = cp.random.rand(H, W).astype(cp.float32)
    output_matrix = cp.zeros((W, H), dtype=cp.float32)
    
    # è®¡ç®—ç½‘æ ¼å¤§å°
    grid_rows = H // tile_h  # 16
    grid_cols = W // tile_w  # 8
    grid = (grid_rows, grid_cols, 1)
    
    # å¯åŠ¨å†…æ ¸
    stream = cp.cuda.get_current_stream()
    ct.launch(stream, grid, matrix_transpose,
              (input_matrix, output_matrix, tile_h, tile_w))
    
    # éªŒè¯ç»“æœ
    expected = input_matrix.T
    np.testing.assert_array_almost_equal(
        cp.asnumpy(output_matrix), 
        cp.asnumpy(expected)
    )
    
    print("âœ“ Matrix transpose test passed!")

if __name__ == "__main__":
    test_matrix_transpose()
```

### ç¤ºä¾‹ 2ï¼šå¤š Tile å¤„ç† - æ»‘åŠ¨çª—å£

```python
@ct.kernel
def sliding_window_avg(input_arr, output_arr, 
                       tile_size: ct.Constant[int],
                       window_size: ct.Constant[int]):
    """
    è®¡ç®—æ»‘åŠ¨çª—å£å¹³å‡å€¼
    
    æ¼”ç¤ºä¸€ä¸ª Block å¤„ç†å¤šä¸ª Tile
    """
    pid = ct.bid(0)
    
    # æ¯ä¸ª Block å¤„ç† 3 ä¸ªç›¸é‚»çš„ Tile
    # å½“å‰ Tile
    current_tile = ct.load(input_arr, 
                          index=(pid,), 
                          shape=(tile_size,))
    
    # å‰ä¸€ä¸ª Tileï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if pid > 0:
        prev_tile = ct.load(input_arr, 
                           index=(pid - 1,), 
                           shape=(tile_size,))
    else:
        prev_tile = ct.zeros(shape=(tile_size,))
    
    # åä¸€ä¸ª Tileï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if pid < ct.grid_dim(0) - 1:
        next_tile = ct.load(input_arr, 
                           index=(pid + 1,), 
                           shape=(tile_size,))
    else:
        next_tile = ct.zeros(shape=(tile_size,))
    
    # è®¡ç®—å¹³å‡å€¼ï¼ˆç®€åŒ–ç‰ˆï¼‰
    avg = (prev_tile + current_tile + next_tile) / 3.0
    
    # å­˜å‚¨ç»“æœ
    ct.store(output_arr, index=(pid,), tile=avg)

def test_sliding_window():
    n = 1024
    tile_size = 32
    
    input_arr = cp.arange(n, dtype=cp.float32)
    output_arr = cp.zeros(n, dtype=cp.float32)
    
    grid = (n // tile_size, 1, 1)
    stream = cp.cuda.get_current_stream()
    
    ct.launch(stream, grid, sliding_window_avg,
              (input_arr, output_arr, tile_size, 3))
    
    print("âœ“ Sliding window test passed!")
```

### ç¤ºä¾‹ 3ï¼šæ¡ä»¶æ‰§è¡Œä¸å¾ªç¯

```python
@ct.kernel
def iterative_refinement(data, 
                        iterations: ct.Constant[int],
                        threshold: ct.Constant[float],
                        tile_size: ct.Constant[int]):
    """
    è¿­ä»£ç²¾ç‚¼ç®—æ³•
    
    æ¼”ç¤ºæ§åˆ¶æµå’Œå¸¸é‡å‚æ•°çš„ä½¿ç”¨
    """
    pid = ct.bid(0)
    
    # åŠ è½½æ•°æ®
    tile = ct.load(data, index=(pid,), shape=(tile_size,))
    
    # è¿­ä»£å¤„ç†
    for iter in range(iterations):
        # åº”ç”¨å¹³æ»‘æ“ä½œ
        tile = tile * 0.9 + 0.1
        
        # æ¡ä»¶å¤„ç†
        if iter > iterations // 2:
            # ååŠéƒ¨åˆ†è¿­ä»£ä½¿ç”¨ä¸åŒçš„ç­–ç•¥
            tile = tile * threshold
        else:
            # å‰åŠéƒ¨åˆ†è¿­ä»£
            tile = tile + (1.0 - threshold)
    
    # æœ€ç»ˆå½’ä¸€åŒ–
    if pid % 2 == 0:
        tile = tile * 2.0
    else:
        tile = tile * 0.5
    
    # å­˜å‚¨ç»“æœ
    ct.store(data, index=(pid,), tile=tile)
```

---

## æ€»ç»“

### å…³é”®è¦ç‚¹

1. **Block vs Tile**
   - Block = æ‰§è¡Œå•å…ƒ
   - Tile = æ•°æ®å•å…ƒ
   - ä¸€ä¸ª Block å¯ä»¥å¤„ç†å¤šä¸ª Tile

2. **æ‰§è¡Œç©ºé—´**
   - Host Codeï¼ˆCPUï¼‰
   - Tile Codeï¼ˆGPU - Tile æŠ½è±¡ï¼‰
   - SIMT Codeï¼ˆGPU - ä¼ ç»Ÿ CUDAï¼‰

3. **å‡½æ•°ç±»å‹**
   - `@ct.kernel`: å†…æ ¸ï¼ŒGrid å…¥å£
   - `@ct.function`: Tile å‡½æ•°ï¼Œå¯å¤ç”¨é€»è¾‘
   - è‡ªåŠ¨æ¨æ–­ï¼šæœªæ ‡æ³¨å‡½æ•°è‡ªåŠ¨åŠ å…¥æ‰§è¡Œç©ºé—´

4. **Python å­é›†**
   - æ—  Python è¿è¡Œæ—¶
   - å¯¹è±¡ä¸å¯å˜ï¼ˆé™¤äº†æ•°ç»„å‚æ•°ï¼‰
   - æ”¯æŒåŸºæœ¬æ§åˆ¶æµ

5. **å¹¶è¡Œæ€§**
   - Block çº§ï¼šæ˜¾å¼æŒ‡å®š
   - Thread çº§ï¼šè‡ªåŠ¨å¤„ç†
   - Tile æ“ä½œï¼šè‡ªåŠ¨å¹¶è¡ŒåŒ–

6. **å¸¸é‡æ€§**
   - å¸¸é‡åµŒå…¥ï¼šç¼–è¯‘æ—¶ä¼˜åŒ–
   - ç±»å‹æç¤ºï¼š`ct.Constant[T]`
   - ä¸åŒå€¼è§¦å‘é‡æ–°ç¼–è¯‘

### æœ€ä½³å®è·µ

âœ… **æ¨èåšæ³•ï¼š**
- ä½¿ç”¨å¸¸é‡åµŒå…¥æ ‡æ³¨ Tile å½¢çŠ¶å‚æ•°
- åˆç†ç»„ç»‡ Grid å¤§å°ä»¥åŒ¹é…é—®é¢˜è§„æ¨¡
- åˆ©ç”¨ `@ct.function` å¤ç”¨ä»£ç 
- è®©ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­æ‰§è¡Œç©ºé—´ï¼ˆç®€å•å‡½æ•°ï¼‰

âŒ **é¿å…çš„åšæ³•ï¼š**
- ä¸è¦æ··æ·† Block å’Œ Tile çš„æ¦‚å¿µ
- ä¸è¦åœ¨ Tile Code ä¸­ä½¿ç”¨æœªæ”¯æŒçš„ Python ç‰¹æ€§
- ä¸è¦å¯¹é¢‘ç¹å˜åŒ–çš„å‚æ•°ä½¿ç”¨å¸¸é‡åµŒå…¥
- ä¸è¦ä¼ é€’åˆ«åæ•°ç»„ç»™å†…æ ¸

---

## ä¸‹ä¸€æ­¥

- [æ•°æ®æ¨¡å‹](data-model.MD)ï¼šæ·±å…¥ç†è§£ Tile æ•°æ®ç±»å‹
- [å†…å­˜æ¨¡å‹](memory-model.MD)ï¼šæŒæ¡å†…å­˜å±‚æ¬¡å’Œä¼˜åŒ–
- [æ“ä½œå‚è€ƒ](operations.MD)ï¼šå­¦ä¹ æ‰€æœ‰å¯ç”¨æ“ä½œ
- [æ€§èƒ½è°ƒä¼˜](performance-tuning.MD)ï¼šä¼˜åŒ–æŠ€å·§å’Œæœ€ä½³å®è·µ

---

**ç‰ˆæƒå£°æ˜**: Copyright Â© 2025, NVIDIA Corporation.  
**è®¸å¯è¯**: Apache-2.0

