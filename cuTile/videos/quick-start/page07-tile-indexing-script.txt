现在，我们来深入理解 cuTile 编程最核心的概念：Tile 索引机制。

这是决定你是否真正掌握 cuTile 的关键！

首先，记住这个核心公式：实际内存位置 等于 index 乘以 shape，也就是 pid 乘以 tile_size。

让我们通过一个具体例子理解。假设有一个长度为 16 的向量，每个 Tile 包含 4 个元素，需要 4 个处理器。

看中间的内存布局图。完整的向量包含 16 个元素，索引从 0 到 15。

我们将它划分为 4 个 Tile：
- Tile 0 包含元素 0 到 3
- Tile 1 包含元素 4 到 7
- Tile 2 包含元素 8 到 11
- Tile 3 包含元素 12 到 15

关键来了！看底部的处理器映射。

处理器 0 的 pid 是 0，它加载 Tile 0。计算过程是：0 乘以 4 到 0 乘以 4 加 4，结果是元素范围 [0:4]。

处理器 1 的 pid 是 1，加载 Tile 1。计算是：1 乘以 4 到 1 乘以 4 加 4，结果是 [4:8]。

处理器 2 的 pid 是 2，加载 Tile 2。计算是：2 乘以 4 到 2 乘以 4 加 4，结果是 [8:12]。

处理器 3 的 pid 是 3，加载 Tile 3。计算是：3 乘以 4 到 3 乘以 4 加 4，结果是 [12:16]。

看到了吗？index 参数不是元素索引，而是 Tile 的编号！通过 pid 乘以 tile_size，我们才得到实际的元素位置。

理解这个机制，你就掌握了 cuTile 的精髓：每个处理器通过自己的 pid，自动知道要处理哪块数据，无需手动计算复杂的线程索引。这就是 Tile 级编程的魅力！
