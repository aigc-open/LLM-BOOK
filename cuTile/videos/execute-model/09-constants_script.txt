本节讲解常量性和常量嵌入，这是 cuTile 的重要优化特性。

某些功能需要在编译时静态已知的参数，这些参数必须是常量对象。

让我们看左上角，什么是常量表达式呢？

第一类是字面量对象，比如 x 等于 42，y 等于 3.14，这些直接写在代码里的值都是常量。

第二类是整数算术表达式。如果操作数都是字面量，结果也是常量。比如 a 等于 10 加 20，在编译时就能确定是 30。

第三类是从常量赋值的对象。tile_size 等于 16 是常量，那么 double 等于 tile_size 乘 2 也是常量，值为 32。

第四类是全局常量，在编译或启动时定义的全局对象。

现在看右上角的常量嵌入。这是一个强大的优化技术。

如果内核参数被标记为常量嵌入，那么参数的所有使用都像被字面值替换一样。每个不同的参数值都会生成独立的内核机器码。常量参数的机器表示为 0 字节，不占用寄存器或内存。

常量嵌入的优点是：编译器可以进行更激进的优化，比如循环展开、内联操作。使用更少的寄存器，提高性能。

缺点是：每个不同的值都需要编译一次，会增加编译时间。如果参数值的范围很大，会生成很多不同的内核版本。

看中间的代码示例。我们使用 ct.Constant 来标注参数。

内核定义时，tile_size 参数的类型标注为 ct.Constant[int]，表示这是一个整数类型的常量嵌入参数。scale_factor 标注为 ct.Constant[float]。

在内核中，tile_size 在编译时已知，编译器可以对 ct.load 进行优化。scale_factor 也在编译时已知，可以优化乘法运算。

启动内核时，我们传入具体的值 16 和 2.5。第一次调用会编译并缓存这个组合。

注意，如果使用不同的值，比如 tile_size 等于 32，会触发重新编译！系统会为新的参数组合生成新的内核代码。

看底部的最佳实践。

推荐使用常量嵌入的场景包括：Tile 形状参数，因为形状必须在编译时已知。循环边界，如果你希望编译器展开循环的话。

避免使用常量嵌入的场景包括：频繁变化的参数，会导致大量重新编译，影响性能。大范围的参数值，会生成大量不同的内核版本，增加代码缓存大小。

合理使用常量嵌入，可以让你的 GPU 程序获得更好的性能！

