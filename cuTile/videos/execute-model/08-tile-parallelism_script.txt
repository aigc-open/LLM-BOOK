本节讲解 Tile 并行性，这是 cuTile 最强大的特性之一。

让我们看顶部的并行执行模型图示。

假设我们有一个包含 128 个元素的 Tile，标记为 e0、e1、e2、e3 等等。当 Block 执行一个接受 Tile 作为参数的函数时，它会自动将这些元素的计算并行化。

看中间的箭头，每个元素会被自动映射到一个线程上。e0 分配给 Thread 0，e1 分配给 Thread 1，e2 分配给 Thread 2，以此类推。这个映射过程是隐式的，完全由系统自动完成。

所有线程并行执行相同的操作，但处理不同的元素。这就是 SIMT，单指令多线程的核心思想。

看右边的代码示例。我们定义了一个 process_tile 函数，它接受一个 Tile 作为参数。函数内部对 Tile 进行乘法和加法运算。这些运算看起来像是标量操作，但实际上会被自动并行化。

在内核函数中，我们加载一个包含 128 个元素的 Tile，然后调用 process_tile。这个调用会触发自动并行执行，128 个元素的计算会分配给多个线程同时进行。

现在看底部的自动同步保证。这是 cuTile 的另一个重要特性。

除非另有说明，函数执行将在函数返回前完成。这意味着，当一个 Tile 操作返回时，所有的线程都已经完成了它们的工作，结果已经就绪。

让我们对比 cuTile 和传统 CUDA。

在 cuTile 中，你只需写 result 等于 tile_a 加 tile_b，系统会自动处理所有的同步问题，无需显式调用任何同步函数。

而在传统 CUDA 中，当你使用共享内存或者需要线程间通信时，必须显式调用 __syncthreads 函数来同步线程。忘记同步会导致数据竞争和错误的结果。

cuTile 的核心优势就在这里：Tile 操作自动并行，自动同步，你无需手动管理线程和同步点。这大大简化了 GPU 编程的复杂度，让你可以专注于算法本身。

